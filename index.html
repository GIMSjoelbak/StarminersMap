<!DOCTYPE html>
<html lang ="en">
<head>
<meta http-equiv="Access-Control-Allow-Origin" content="*" />
  <base target="_top">
  <meta charset="utf-8">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.3/dist/leaflet.css"
     integrity="sha256-kLaT2GOSpHechhsozzB+flnD+zUyjE2LlfWPgU04xyI="
     crossorigin=""/>
   <script src="https://unpkg.com/leaflet@1.9.3/dist/leaflet.js"
     integrity="sha256-WBkoXOwTeyKclOHuWtc+i2uENFpDZ9YPdf5Hf+D7ewM="
     crossorigin=""></script>
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.3/jquery.min.js"></script>
  <style>
.flash {
  animation: flash 1s;
}

@keyframes flash {
  0% {
    opacity: 1;
  }
  25% {
    opacity: 0;
	}
50% {
	opacity: 1;
	}
75% {
	opacity: 0;
  }
  100% {
    opacity: 1;
  }
}
body {
      padding: 0;
      margin: 0;
    }
html, body, #map {
      height: 100%;
      width: 100%;
    }
/* Make the table cells have padding */
table {
  border-collapse: collapse;
  width: 100%;
}

td {
  padding: 3px;
font-size: 12px;
border: 1px solid black;
}

/* Set a fixed width for the table cells */
th, td {
  width: 20%;
  max-width: 250px;
}

/* Prevent text from wrapping */
td {
  white-space: nowrap;
  overflow: hidden;
}
td:last-child {
  width: 30%;
}
.leaflet-popup-content-wrapper {
  width: auto !important;
  max-width: 100% !important;
}
  </style>
  </head>
  <body>	  			
    <div id="map"</div>
	  <script src="coordinates.js"></script>
<script>  
	var polygon0, polygon1, polygon2;
Promise.all([  fetch('./images/Asgarnia.geojson'),  fetch('./images/Karamja.geojson'),  fetch('./images/Feldip.geojson')])
.then(responses => Promise.all(responses.map(response => response.json())))
.then(result => {
  var polygon0 = L.geoJSON(result[0], {
    style: {
      fillColor: 'DarkGreen',
      fillOpacity: 0.5
    }
  }).addTo(map);

  var polygon1 = L.geoJSON(result[1], {
    style: {
      fillColor: 'DarkGreen',
      fillOpacity: 0.5
    }
  }).addTo(map);

  var polygon2 = L.geoJSON(result[2], {
    style: {
      fillColor: 'Brown',
      fillOpacity: 0.5
    }
  }).addTo(map);


// Define a separate function to fetch data and update table
  function fetchDataAndUpdateTable() {
 fetch("stars.json?timestamp=" + Date.now())
      .then((response) => response.json())
      .then((data) => {
	createPopup(polygon0, 0, data);
	createPopup(polygon1, 1, data);
	createPopup(polygon2, 2, data);
	    console.log(data); // log the retrieved data
	  });
	   // Keep track of the previous data
  var prevData = null;
  var polygonType = null;
	         while (table.rows.length > 1) {
          table.deleteRow(-1);
        }

        var filteredData = data.filter((d) => d.location === location);
	var filteredData2 = filteredData.filter((d) => d.calledLocation !== "");

        // Compare the previous data with the new data
	var isDataChanged = false;
      if (prevData !== null) {
         var prevData2 = prevData.filter((d) => d.calledLocation !== "");
        isDataChanged = filteredData2.length > prevData2.length;
      }
        prevData = filteredData;
       // Flash the polygon if data has changed and polygon type is defined
        if (isDataChanged && polygonType !== null) {
          if (polygonType === "Polygon") {
            polygon.getElement().classList.add("flash");
            setTimeout(function () {
              polygon.getElement().classList.remove("flash");
            }, 2000);
          } else if (polygonType === "GeoJSON") {
            polygon.eachLayer(function (layer) {
              layer.getElement().classList.add("flash");
              setTimeout(function () {
                layer.getElement().classList.remove("flash");
              }, 2000);
            });
          }
        }
	}
	 // Call the fetch data function initially
  fetchDataAndUpdateTable();

  // Call the fetch data function every 30 seconds using setInterval
  setInterval(fetchDataAndUpdateTable, 30000);
});

	
function createPopup(polygon, location, data) {
  var table = document.createElement("table");
  var headerRow = table.insertRow();
  var header1 = headerRow.insertCell(0);
  var header2 = headerRow.insertCell(1);
  var header3 = headerRow.insertCell(2);
  var header4 = headerRow.insertCell(3);
  var header5 = headerRow.insertCell(4);
  var header6 = headerRow.insertCell(5);
  header1.innerHTML = "<b>Location</b>";
  header2.innerHTML = "<b>World</b>";
  header3.innerHTML = "<b>Min Time</b>";
  header4.innerHTML = "<b>Max Time</b>";
  header5.innerHTML = "<b>Time until</b>";	
  header6.innerHTML = "<b>Called Location</b>";
  
	function updateTable() {
 
        filteredData.forEach((d) => {
          var row = table.insertRow();
          var cell1 = row.insertCell(0);
          var cell2 = row.insertCell(1);
          var cell3 = row.insertCell(2);
          var cell4 = row.insertCell(3);
	  var cell5 = row.insertCell(4);
          var cell6 = row.insertCell(5);
		  var locationWord;
  if (d.location === 2) {
    locationWord = "Feldip/Isle of Souls";
  } else if (d.location === 1) {
    locationWord = "Karamja/Crandor";
} else if (d.location === 0) {
    locationWord = "Asgarnia";
  } else {
    locationWord = d.location;
  }
          cell1.innerHTML = locationWord;
          cell2.innerHTML = d.world;	
        // Convert Unix timestamp to normal time format
        var minTime = new Date(d.minTime * 1000).toLocaleString();
        var maxTime = new Date(d.maxTime * 1000).toLocaleString();
          cell3.innerHTML = minTime;
          cell4.innerHTML = maxTime;
	var now = Date.now();
        var relativeTime = Math.round((d.minTime * 1000 - now) / 60000);
        if (relativeTime > 0) {
          relativeTime = -relativeTime;
        }
          cell5.innerHTML = relativeTime + " min";
          cell6.innerHTML = d.calledLocation;
		    });
	}
	  // Determine the type of the polygon argument and store it
  if (polygon instanceof L.Polygon) {
    polygonType = "Polygon";
  } else if (polygon instanceof L.GeoJSON) {
    polygonType = "GeoJSON";
  }
			updateTable();
	console.log('complete');		

  var popup = L.popup({ maxWidth: 700 }).setContent(table);
  polygon.bindPopup(popup);
}
	  </script>
  </body>
 </html>
  
      
  
  
      
  
